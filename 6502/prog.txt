m200000; bootloader moment frfr :skull:
a9;
3e; load > into char buffer
20;
00;
10;
20;
a9; print to the screen
06;
8d;
ff;
ff;
1f;
04; keyboard
a9; initialise zero page
00;
85;
00;
a9;
1f;
85;
01;
a9;
20;
85;
02;
e6; increment the command number
01;
a9;
25; final command number (+20)
c5; cmp
01;
90; branch if carry clear
a1;
a0; load 00 into Y
00;
20; compare IO and string
30;
10;
20;
90; branch if carry clear
90; back to increment
c8; increment y (because it points to the newline char)
84; load the address of the command into 00
00;
6c;
00;
00;
00;
07; exit without saving; this shouldn't happen but it's a nice failsafe
m201000; print char from A reg
8d;
fe;
ff;
1f;
a9; lda
00;
8d; sta
ff;
ff;
1f;
a9; lda
01;
8d; sta
ff;
ff;
1f;
60;
m201030; compare IO with ZP string
b1; go to address 00 (INS_LDA_IY)
00; and then go to *that* address plus Y
d9; cmp_ay
00;
ff;
1f;
08; save processor status
c8; increment Y
c9; cmp
0a; newline
f0; branch if equal
05;
28; load processor status
f0; branch if equal
8f;
18;
60; it is not equal: clear carry
88; decrement Y
b9; load accumulator abs_y
00;
ff;
1f;
28; pull processor status
c9; cmp
0a; newline
d0; branch if not equal
8c;
38;
60; it is equal: set carry
m202000; data for bootloader
65; command "exit"
78;
69; nice
74;
0a; newline is terminating character
07; exit
m202100; second command
73; cmd "save"
61;
76;
65;
0a;
0b; save code
4c;
00;
00;
20;
m202200; cmd "scan manual"
73; 's'
63; 'c'
61;
6e;
20;
6d;
61;
6e;
75;
61;
6c;
0a; '\n'
a9;
3e; load > into char buffer
20;
00;
10;
20;
a9; print to the screen
06;
8d;
ff;
ff;
1f;
04; keyboard
20; jmp
00;
00;
21;
4c; jump back
00;
00;
20;
07; exit (shouldn't happen)
m202300; cmd "scan auto"
73; 's'
63; 'c'
61;
6e;
20;
61;
75;
74;
6f;
0a; '\n'
20; loop through entire memory looking for header
00;
f0;
20;
4c; jump back
00;
00;
20;
m202400; cmd "boot"
62;
6f;
6f;
74;
0a;
a5; load A
82; most significant byte of address
c9;
20;
90; if it's not more than or equal to 20 (ROM start), then GET OUT!!!!!!
04;
6c; jump indirect
80;
00;
00;
a9; load error code 00 onto the stack
30;
48;
48;
20;
00;
e0;
20;
4c; go back
00;
00;
20;
m202500; cmd "info"
69;
6e;
66;
6f;
0a;
a9; load a string onto the stack and shii
00; null
48; push the character
a9;
0a; '\n'
48; push the character
a9;
31; '1'
48; push the character
a9;
2e; '.'
48; push the character
a9;
30; '0'
48; push the character
a9;
76; 'v'
48; push the character
a9;
20; ' '
48; push the character
a9;
3a; ':'
48; push the character
a9;
42; 'B'
48; push the character
a9;
53; 'S'
48; push the character
48; push the character
48; push the character
48; push the character
20;
00;
e1;
20;
ba; tsx
8a; txa
18; clc
69; A += 13
13;
aa; tax
9a; txs
4c;
00;
00;
20;
m20e000; subroutine to print an error code stored in the stack
ba; tsx
e8;
e8;
e8;
e8;
a9; load null '00'
00;
48; push the character
a9; load character '\n'
0a;
48; push the character
bd; load character 2 of error code
00;
01;
00;
48; push the character
e8;
bd; load character 1 of error code
00;
01;
00;
48; push the character
a9; load character ' '
20;
48; push the character
a9; load character ':'
3a;
48; push the character
a9; load character 'R'
52;
48; push the character
48; push the character again
a9; load character 'E'
45;
48; push the character
20;
00;
e1;
20;
ba; tsx
8a; txa
18; clc
69; A += 9;
09;
aa; tax
9a; txs
60;
m20e100; subroutine to print a string stored in the stack
ba; tsx
e8; inx
e8;
e8; start point for loop
bd; lda abs_x
01;
01;
00;
c9; is it 0?
00;
f0; branch if equal
08;
20; print the character
00;
10;
20;
4c; jump to start
03;
e1;
20;
a9; print to the screen
06;
8d;
ff;
ff;
1f;
60; rts
m20f000; loop through memory looking for the OS
a9; initialise addresses 80, 81, and 82 in ZP
ff;
85;
80;
85;
81;
a9; store 19 in addr 82 (full addr stored is 19ffff)
19;
85;
82;
a0; load 00 into Y
00;
a2; load 01 into X (X is set if last is zero)
01;
20; inc thing
00;
ff;
20;
b1; load accumulator indirect Y
80;
c9; compare what's there with 0
00;
f0; branch back to ldx_im
8c;
e0; cmp X
00;
08; push ps
a2; load 0 into X
00;
28; pull ps
f0; branch back to lda_iy
8d;
c9; the last was 0 and this is not 0
ff;
d0; if it's not ff, branch back to the beginning
99;
c8; increment Y
b1; load accumulator indirect Y
80;
c9; is the first letter o?
6f;
d0; branch if it isn't to the start
a0;
c8; increment Y
b1; load accumulator indirect Y
80;
c9; is the second letter s?
73;
d0; branch if it isn't to the start
a7;
c8; increment Y
b1; load accumulator indirect Y
80;
c9; is the third letter null?
00;
d0; branch if it isn't to the start
ae;
20; inc thing
00;
ff;
20;
20; inc thing
00;
ff;
20;
20; inc thing
00;
ff;
20;
20; inc thing
00;
ff;
20;
60; rts
m20ff00
e6; increment low byte
80;
d0; if it's not zero, skip
0a;
e6; increment medium byte
81;
d0; if it's not zero, skip
06;
e6; increment high byte
82;
d0; if it's not zero, skip
02;
07; exit without saving
60;
m210000; IO string to hex subroutine (I'm bad at binary ok don't judge)
a0; load Y 00
00;
a2; load X 00
00;
b9; load A abs_y
00;
ff;
1f;
20; jsr 210040
40;
00;
21;
0a; asl (accumulator)
0a;
0a;
0a;
9d; thing
80;
00;
00;
c8; increment Y
b9; load A abs_y
00;
ff;
1f;
20; jsr 210040
40;
00;
21;
18; clear carry (probably unnecessary but I'm not taking any chances)
7d; adc AX
80;
00;
00;
9d; thing
80;
00;
00;
c8; increment Y
e8; increment X
c0; compare Y
05;
b0; branch if Y >= 05 (to RTS)
02;
90;
aa;
60; rts
m210040; hex digit to dec
c9; cmp_im
61; ascii for a
90; branch if carry clear (is reg A < ascii a)
04;
18; clear carry
e9; subtract immediate
57;
60; rts
18; clear carry
e9; subtract immediate
30;
60; rts
m210200; operating system
00;
ff; header
6f; name is 'os' (no newline)
73;
00;
a9; load A '*' (this is address 210205)
2a;
20; print A reg
00;
10;
20;
a9; load A '\n'
0a;
20; print A reg
00;
10;
20;
a9; print to the screen
06;
8d;
ff;
ff;
1f;
07; exit without saving
m210100; other file (testing)
00;
ff;
6f;
73;
0a;
a9; load A '6' (this is address 210105)
36;
20; print A reg
00;
10;
20;
a9; load A '\n'
0a;
20; print A reg
00;
10;
20;
a9; print to the screen
06;
8d;
ff;
ff;
1f;
07;
mfffffa;
00;
00;
20;