m100000; bootloader moment frfr :skull:
a9;
3e; load > into char buffer
20;
30;
00;
10;
a9; print to the screen
06;
8d;
ff;
ff;
0f;
04; keyboard
a9; initialise zero page
00;
85;
00;
a9;
02;
85;
01;
a9;
10;
85;
02;
e6; increment the command number
01;
a9;
15; final command number (+10)
c5; cmp
01;
90; branch if carry clear
a1;
a0; load 00 into Y
00;
20; compare IO and string
60;
00;
10;
90; branch if carry clear
90; back to increment
c8; increment y (because it points to the newline char)
84; load the address of the command into 00
00;
6c;
00;
00;
00;
07; exit without saving; this shouldn't happen but it's a nice failsafe
m100030; print char from A reg
8d;
fe;
ff;
0f;
a9; lda
00;
8d; sta
ff;
ff;
0f;
a9; lda
01;
8d; sta
ff;
ff;
0f;
60;
m100060; compare IO with ZP string
b1; go to address 00 (INS_LDA_IY)
00; and then go to *that* address plus Y
d9; cmp_ay
00;
ff;
0f;
08; save processor status
c8; increment Y
c9; cmp
0a; newline
f0; branch if equal
05;
28; load processor status
f0; branch if equal
8f;
18;
60; it is not equal: clear carry
88; decrement Y
b9; load accumulator abs_y
00;
ff;
0f;
28; pull processor status
c9; cmp
0a; newline
d0; branch if not equal
8c;
38;
60; it is equal: set carry
m100300; data for bootloader
65; command "exit"
78;
69; nice
74;
0a; newline is terminating character
07; exit
m100400; second command
73; cmd "save"
61;
76;
65;
0a;
0b; save code
4c;
00;
00;
10;
m100500; cmd "scan manual"
73; 's'
63; 'c'
61;
6e;
20;
6d;
61;
6e;
75;
61;
6c;
0a; '\n'
a9;
3e; load > into char buffer
20;
30;
00;
10;
a9; print to the screen
06;
8d;
ff;
ff;
0f;
04; keyboard
20; jmp
40;
11;
10;
4c; jump back
00;
00;
10;
07; exit (shouldn't happen)
m100600; cmd "scan auto"
73; 's'
63; 'c'
61;
6e;
20;
61;
75;
74;
6f;
0a; '\n'
20; loop through metadata looking for the file
80;
10;
10;
4c; jump back
00;
00;
10;
m100700; cmd "boot"
62;
6f;
6f;
74;
0a;
a5; load A
82; most significant byte of address
c9;
10;
90; if it's not more than or equal to 10 (ROM start), then GET OUT!!!!!!
04;
6c; jump indirect
80;
00;
00;
a9; load error code 00 onto the stack
30;
48;
48;
20; print err 00
00;
10;
10;
4c; go back
00;
00;
10;
m100800; cmd "info"
69;
6e;
66;
6f;
0a;
a9; load a string onto the stack and shii
00; null
48; push the character
a9;
0a; '\n'
48; push the character
a9;
31; '1'
48; push the character
a9;
2e; '.'
48; push the character
a9;
30; '0'
48; push the character
a9;
76; 'v'
48; push the character
a9;
20; ' '
48; push the character
a9;
3a; ':'
48; push the character
a9;
42; 'B'
48; push the character
a9;
53; 'S'
48; push the character
48; push the character
48; push the character
48; push the character
20;
40;
10;
10;
ba; tsx
8a; txa
18; clc
69; A += 13
13;
aa; tax
9a; txs
4c;
00;
00;
10;
m101000; subroutine to print an error code stored in the stack
ba; tsx
e8;
e8;
e8;
e8;
a9; load null '00'
00;
48; push the character
a9; load character '\n'
0a;
48; push the character
bd; load character 2 of error code
00;
01;
00;
48; push the character
e8;
bd; load character 1 of error code
00;
01;
00;
48; push the character
a9; load character ' '
20;
48; push the character
a9; load character ':'
3a;
48; push the character
a9; load character 'R'
52;
48; push the character
48; push the character again
a9; load character 'E'
45;
48; push the character
20;
40;
10;
10;
ba; tsx
8a; txa
18; clc
69; A += 9;
09;
aa; tax
9a; txs
60;
m101040; subroutine to print a string stored in the stack
ba; tsx
e8; inx
e8;
e8; start point for loop
bd; lda abs_x
01;
01;
00;
c9; is it 0?
00;
f0; branch if equal
08;
20; print the character
30;
00;
10;
4c; jump to start
40;
10;
10;
a9; print to the screen
06;
8d;
ff;
ff;
0f;
60; rts
m101080; go to file metadata looking for a file stored in stack and store it at 0x80
b8; tsx
e8; inx * 3
e8;
e8;
a9; initialise ZP (zero page my beloved)
ff;
85; sta zp 80
80;
a9; lda 20
1f;
85; sta zp 81
81;
a9; lda 10
10;
85; sta zp 82
82;
a0; load Y 00
00;
e8; increment X and also LOOP START
20; jsr inc addr at 0x80
30;
11;
10;
bd;
00;
01;
00;
d1; compare A immediate 1c
1c;
f0; Branch if equal to the end where it compares 80 indirect Y with 1c
04;
d1; compare A indirect Y
80;
f0; Branch if equal to the start of the loop
91;
d0; branch if not equal to the reset thing
0b;
b1; load A indirect y
80;
c9; compare with 1c (end of line)
1c;
d0; branch if it isn't equal to the reset thing
05;
20; is equal
30;
11;
10;
60; rts
20; jsr inc addr at 0x80 (reset) also beginning of loop 2
30;
11;
10;
b1; load A indirect y
80;
c9; cmp with 1c;
1c;
d0; branch to beginning of loop 2
8a;
20; jsr inc addr at 0x80 (reset) also beginning of loop 2
30;
11;
10;
20; jsr inc addr at 0x80 (reset) also beginning of loop 2
30;
11;
10;
20; jsr inc addr at 0x80 (reset) also beginning of loop 2
30;
11;
10;
4c; jump to beginning
80;
10;
10;
m101130; increment an address stored at 0x80
e6; increment low byte
80;
d0; if it's not zero, skip
0a;
e6; increment medium byte
81;
d0; if it's not zero, skip
06;
e6; increment high byte
82;
d0; if it's not zero, skip
02;
07; exit without saving
60;
m101140; IO string to hex subroutine (I'm bad at binary ok don't judge)
a0; load Y 00
00;
a2; load X 00
00;
b9; load A abs_y
00;
ff;
0f;
20; jsr hex to dec
80;
11;
10;
0a; asl (accumulator)
0a;
0a;
0a;
9d; load character into ZP
80;
00;
00;
c8; increment Y
b9; load A abs_y
00;
ff;
0f;
20; jsr hex to dec
80;
11;
10;
18; clear carry (probably unnecessary but I'm not taking any chances)
7d; adc AX
80;
00;
00;
9d; load character
80;
00;
00;
c8; increment Y
e8; increment X
c0; compare Y
05;
b0; branch if Y >= 05 (to RTS)
02;
90;
aa;
60; rts
m101180; hex digit to dec
c9; cmp_im
61; ascii for a
90; branch if carry clear (is reg A < ascii a)
04;
18; clear carry
e9; subtract immediate
57;
60; rts
18; clear carry
e9; subtract immediate
30;
60; rts
m102000; File metadata
01; binary
01; root
00; No more directories
6f; 'o'
73; 's'
00; No more name
04; Size: 4 kb
00;
1c; End metadata (not really)
00; Address: 122800
28;
12;
m122800; operating system (134 kb ahead of start)
a9; load A '*'
2a;
20; print A reg
30;
00;
10;
a9; load A '\n'
0a;
20; print A reg
30;
00;
10;
a9; print to the screen
06;
8d;
ff;
ff;
0f;
07; exit without saving
mfffffa;
00;
00;
10;